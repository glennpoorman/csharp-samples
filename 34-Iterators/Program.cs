// ------------------------------------------------------------------------------------------------------
// Iterators
//
// Iterators in C#.
//
// C# allows any class to be implemented such that you can iterate over objects contained in the class.
// There is a "long way" and a "short way" to do this.
//
// In C# 1 (the long way), defining a collecton to be interated over meant implementing "IEnumerable".
// That interface declares one method.
//
//     public IEnumerator GetEnumerator();
//
// The implementation of that method is meant to create and returne a custom iterator object designed
// specifically to iterate over your collection. The iterator is required to implement "IEnumerator"
// which declares the following methods/properties:
//
//     public object Current { get; }
//     public bool MoveNext();
//     public void Reset();
//
// C# 2 (the short way) introduced language support for the implementation of "IEnumerator". By using
// the "yield return" statement in the collection's "GetEnumerator" method, the enumerator object will
// be automatically generated. How this works will make more sense when we implement "GetEnumerator" in
// the code below.
//
// In addition to the changes in C# 2, the introduction of generics also meant the introduction of two
// new interfaces "IEnumerable<T>" and "IEnumerator<T>".
//
// In a modern C# application, you can forget about implementing these "the long way". In addition, you
// skip straight to implementing "IEnumerable<T>" and this will handle both generic and non-generic
// iteration.
//
// This sample extends the previous "Interfaces" sample such that our list of drawable objects now
// implements "IEnumerable<IDrawable>".
// ------------------------------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;

namespace Iterators
{
    // Define the "IDrawable" interface.
    //
    public interface IDrawable
    {
        // The "Draw" method.
        //
        public void Draw();
    }

    // Define a list designed to contain objects that implement "IDrawable". Unlike our previous list
    // that derived from "List<IDrawable", this list implements "IEnumerable<IDrawable>".
    //
    // Note that the previous sample was really ideal. The class "List<IDrawable>" actually implements
    // the "IEnumerable<IDrawable>" interface. By changing things around here though, you can see an
    // example of implementing this yourself.
    //
    public class DrawableList : IEnumerable<IDrawable>
    {
        // Internally then, we'll use a "List<IDrawable>" to hold our objects that implement "IDrawable".
        // This is by no means a requirement though. You could use anything you like here. Maybe your
        // objects are stored in a database. Maybe your making API calls to fetch objects from a cloud
        // service. As long as you can iterate over them, it's all good.
        //
        private readonly List<IDrawable> collection = new();

        // Add the specified drawable to the list.
        //
        // This method isn't part of any interface so we could name it anything we want. An important
        // thing to consider though is that, if you create one of these lists and attempt to use a list
        // initializer to add some objects upon construction, the compiler will automatically look for
        // a method named "Add" that takes a single "IDrawable". That means if we called this method
        // anything else, attempts to use a list initializer would result in a compile error.
        //
        public void Add(IDrawable drawable) => collection.Add(drawable);

        // Read only "Count" property returns the number of items in the list.
        //
        public int Count => collection.Count;

        // This "GetEnumerator" method is the implementation of the method contained in "IEnumerable<T>".
        // The idea is that this method creates an enumerator object designed to iterate over this
        // collection and returns it to the caller.
        //
        // This is where the syntax gets a little strange. Notice that no actual creation or return of
        // any enumerator object actually takes place. Instead, the "yield" keyword is used. In C#,
        // "yield" tells the compiler that this entire method is an iterator block. Using this code, the
        // enumerator is generated by the compiler and will look something like:
        //
        //     public IDrawable Current => collection[i];
        //     public bool MoveNext() => return (i++ < collection.Count);
        //     public void Reset() => i = 0;
        // 
        public IEnumerator<IDrawable> GetEnumerator()
        {
            for (int i = 0; i < collection.Count; i++)
                yield return collection[i];
        }

        // This "GetEnumerator" method is the non-generic method required by the interface "IEnumerable".
        // It's always a good idea to implement both the generic and non-generic version. Furthermore, it
        // is require when you implement "IEnumerable<T>". Please note the following:
        //
        // 1. Since the signatures of both "GetEnumerator" methods only differ by return type, one of
        //    them has to be identified by the interface name (i.e. "IEnumerable.GetEnumerator") in order
        //    to avoid a name conflict and compile error.
        //
        // 2. You never need to do anything special for this implementation. It's always enough to simply
        //    call the version above.
        //
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    // The "Point" struct.
    //
    public struct Point
    {
        // The X and Y auto-implemented properties of the point coordinates.
        //
        public int X { get; init; }
        public int Y { get; init; }

        // Override "ToString" from the base "object" class.
        //
        public override string ToString() => $"{X}, {Y}";
    }

    // Define the "Shape" class.
    //
    public class Shape : IDrawable
    {
        // The shape center property.
        //
        public Point Center { get; set; }

        // Override "ToString" from the base "object" class.
        //
        public override string ToString() => $"{GetType().Name}, Center = ({Center})";

        // The "Draw" method as defined in "IDrawable".
        //
        public void Draw() => Console.WriteLine(this);
    }

    // Define a class "Circle" that derives from "Shape" and adds a radius.
    //
    public class Circle : Shape
    {
        // Circle radius auto-implemented property.
        //
        public int Radius { get; set; }

        // Override "ToString" from the base "object" class.
        //
        public override string ToString() => $"{base.ToString()}, Radius = ({Radius})";
    }

    // Define a struct "Person" containing a first and last name that is also drawable.
    //
    public struct Person : IDrawable
    {
        // First and last name properties.
        public string FirstName { get; init; }
        public string LastName { get; init; }

        // The "Draw" method as defined in "IDrawable".
        //
        public void Draw() => Console.WriteLine($"Hello! My name is {FirstName} {LastName}!");
    }

    class Program
    {
        static void Main()
        {
            // Create a drawable list and intialize the list with several new shape objects as well as
            // a person object.
            //
            DrawableList drawableList = new()
            {
                new Shape()
                {
                    Center = new Point() { X = 10, Y = 22 }
                },
                new Circle()
                {
                    Center = new Point() { X = 30, Y = 40 },
                    Radius = 101
                },
                new Person()
                {
                    LastName = "Poorman",
                    FirstName = "Glenn"
                },
                new Circle()
                {
                    Center = new Point()
                    { X = 101, Y = 202 },
                    Radius = 12
                }
            };

            // Create an enumerator and use the enumerator methods explicitly to iterate over the list
            // drawing each drawable to the console.
            //
            // Note that the enumerator provides everything you need to use any kind of loop. We use a
            // while loop below but could have just as easily written a for loop something like:
            //
            //     for (IEnumerator<IDrawable> iEnum = drawableList.GetEnumerator(); iEnum.MoveNext();)
            //         iEnum.Current.Draw();
            //
            Console.WriteLine("Display the drawable list explicitly using enumerator methods.");
            IEnumerator<IDrawable> iEnum = drawableList.GetEnumerator();
            while (iEnum.MoveNext())
                iEnum.Current.Draw();

            // You actually never need to explicitly reference an enumerator though. Truth be told, every
            // type of collection in C# implements, at the very least, "IEnumerable" including a simple
            // array. If you use a "foreach" loop to iterator over a collection, the C# compiler will use
            // the iterator methods behind the scenes allowing you to keep your code clean as shown in the
            // "foreach" loop we use below.
            //
            Console.WriteLine("\nDisplay the drawable list using a foreach loop.");
            foreach (IDrawable drawable in drawableList)
                drawable.Draw();
        }
    }
}
